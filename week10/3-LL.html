<script>
    var regexp = /([0-9\.]+)|([ \t]+)|([\r\n]+)|(\*)|(\/)|(\+)|(\-)/g;
    // match group 1: Number, match group 2: Whitespace
    // match group 3: LineTerminator, match group 4: *

    var dictionary = ["Number", "Whitespace", "LineTerminator", "*", "/", "+", "-"];

    // For the syntax function*, the star (asterisk) means  
    // that the function is a generator. And in a generator
    // function, the yield keyword 
    // pauses function execution and returns (yields) a value.
    function* tokenize(source){
        var result = null;
        var lastIndex = null;
        while(true){
            lastIndex = regexp.lastIndex;
            result = regexp.exec(source);                
            if(!result){
               break; 
            } 
            if(regexp.lastIndex - lastIndex > result[0].length){
                break;
            }

            let token = {
                type: null,
                value: null
            }

            for(let i = 1; i<= dictionary.length; i++){
                if(result[i]){
                    token.type = dictionary[i-1];
                    token.value = result[i];
                }
            }
            yield token; 
        }
        yield {type: "EOF"};
    }

    let source = [];
    for(let token of tokenize("10 * 25 * 5")){
        if(token.type!=='Whitespace' && token.type!=='LineTerminator')
            source.push(token);
    }

    function expression(tokens){

    }

    function additiveExpression(source){

    }

    function multiplicativeExpression(source){
        if(source[0].type === "Number"){
            let node = {
                type: "MultiplicativeExpression",
                children: [source[0]]
            }
            source[0] = node;
            return multiplicativeExpression(source);
        }
        if(source[0].type === "MultiplicativeExpression" && source[1] && (source[1].type==="*" || source[1].type==="/")){
            let node = {
                type: "MultiplicativeExpression",
                operator: "*",
                children: [] 
            }
            node.children.push(source.shift());
            node.children.push(source.shift());
            node.children.push(source.shift());
            source.unshift(node);
            return multiplicativeExpression(source);
        }
        // it's a default else branch
        if(source[0].type==="MultiplicativeExpression"){
            return source[0];
        }

        return multiplicativeExpression(source);//It's never be called?
    }

    console.log(multiplicativeExpression(source));
</script>